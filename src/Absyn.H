#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;




/********************   Forward Declarations    ********************/

class Program;
class TopDef;
class Arg;
class ClassInstr;
class Block;
class Stmt;
class Item;
class LatteIdent;
class Type;
class Expr;
class AddOp;
class MulOp;
class RelOp;
class Prog;
class FnDef;
class ClassDefNoInher;
class ClassDefInher;
class Ar;
class MethodDef;
class FieldDef;
class Blk;
class Empty;
class BStmt;
class Decl;
class NoInit;
class Init;
class InitArray;
class InitObj;
class SingleIdent;
class ArrayIdent;
class SelfIdent;
class Ass;
class AssArr;
class AssObj;
class Incr;
class Decr;
class Ret;
class VRet;
class Cond;
class CondElse;
class While;
class Foreach;
class SExp;
class Class;
class Int;
class Str;
class Bool;
class Void;
class ArrayType;
class EVar;
class ELitInt;
class ELitFalse;
class ELitNull;
class ELitTrue;
class EApp;
class EInstanceApp;
class EString;
class Neg;
class Not;
class ECast;
class EMul;
class EAdd;
class ERel;
class EAnd;
class EOr;
class Plus;
class Minus;
class Times;
class Div;
class Mod;
class LTH;
class LE;
class GTH;
class GE;
class EQU;
class NE;
class ListTopDef;
class ListArg;
class ListClassInstr;
class ListStmt;
class ListItem;
class ListLatteIdent;
class ListExpr;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
    virtual ~Visitor() {}
    virtual void visitProgram(Program *p) = 0;
    virtual void visitTopDef(TopDef *p) = 0;
    virtual void visitArg(Arg *p) = 0;
    virtual void visitClassInstr(ClassInstr *p) = 0;
    virtual void visitBlock(Block *p) = 0;
    virtual void visitStmt(Stmt *p) = 0;
    virtual void visitItem(Item *p) = 0;
    virtual void visitLatteIdent(LatteIdent *p) = 0;
    virtual void visitType(Type *p) = 0;
    virtual void visitExpr(Expr *p) = 0;
    virtual void visitAddOp(AddOp *p) = 0;
    virtual void visitMulOp(MulOp *p) = 0;
    virtual void visitRelOp(RelOp *p) = 0;
    virtual void visitProg(Prog *p) = 0;
    virtual void visitFnDef(FnDef *p) = 0;
    virtual void visitClassDefNoInher(ClassDefNoInher *p) = 0;
    virtual void visitClassDefInher(ClassDefInher *p) = 0;
    virtual void visitAr(Ar *p) = 0;
    virtual void visitMethodDef(MethodDef *p) = 0;
    virtual void visitFieldDef(FieldDef *p) = 0;
    virtual void visitBlk(Blk *p) = 0;
    virtual void visitEmpty(Empty *p) = 0;
    virtual void visitBStmt(BStmt *p) = 0;
    virtual void visitDecl(Decl *p) = 0;
    virtual void visitNoInit(NoInit *p) = 0;
    virtual void visitInit(Init *p) = 0;
    virtual void visitInitArray(InitArray *p) = 0;
    virtual void visitInitObj(InitObj *p) = 0;
    virtual void visitSingleIdent(SingleIdent *p) = 0;
    virtual void visitArrayIdent(ArrayIdent *p) = 0;
    virtual void visitSelfIdent(SelfIdent *p) = 0;
    virtual void visitAss(Ass *p) = 0;
    virtual void visitAssArr(AssArr *p) = 0;
    virtual void visitAssObj(AssObj *p) = 0;
    virtual void visitIncr(Incr *p) = 0;
    virtual void visitDecr(Decr *p) = 0;
    virtual void visitRet(Ret *p) = 0;
    virtual void visitVRet(VRet *p) = 0;
    virtual void visitCond(Cond *p) = 0;
    virtual void visitCondElse(CondElse *p) = 0;
    virtual void visitWhile(While *p) = 0;
    virtual void visitForeach(Foreach *p) = 0;
    virtual void visitSExp(SExp *p) = 0;
    virtual void visitClass(Class *p) = 0;
    virtual void visitInt(Int *p) = 0;
    virtual void visitStr(Str *p) = 0;
    virtual void visitBool(Bool *p) = 0;
    virtual void visitVoid(Void *p) = 0;
    virtual void visitArrayType(ArrayType *p) = 0;
    virtual void visitEVar(EVar *p) = 0;
    virtual void visitELitInt(ELitInt *p) = 0;
    virtual void visitELitFalse(ELitFalse *p) = 0;
    virtual void visitELitNull(ELitNull *p) = 0;
    virtual void visitELitTrue(ELitTrue *p) = 0;
    virtual void visitEApp(EApp *p) = 0;
    virtual void visitEInstanceApp(EInstanceApp *p) = 0;
    virtual void visitEString(EString *p) = 0;
    virtual void visitNeg(Neg *p) = 0;
    virtual void visitNot(Not *p) = 0;
    virtual void visitECast(ECast *p) = 0;
    virtual void visitEMul(EMul *p) = 0;
    virtual void visitEAdd(EAdd *p) = 0;
    virtual void visitERel(ERel *p) = 0;
    virtual void visitEAnd(EAnd *p) = 0;
    virtual void visitEOr(EOr *p) = 0;
    virtual void visitPlus(Plus *p) = 0;
    virtual void visitMinus(Minus *p) = 0;
    virtual void visitTimes(Times *p) = 0;
    virtual void visitDiv(Div *p) = 0;
    virtual void visitMod(Mod *p) = 0;
    virtual void visitLTH(LTH *p) = 0;
    virtual void visitLE(LE *p) = 0;
    virtual void visitGTH(GTH *p) = 0;
    virtual void visitGE(GE *p) = 0;
    virtual void visitEQU(EQU *p) = 0;
    virtual void visitNE(NE *p) = 0;
    virtual void visitListTopDef(ListTopDef *p) = 0;
    virtual void visitListArg(ListArg *p) = 0;
    virtual void visitListClassInstr(ListClassInstr *p) = 0;
    virtual void visitListStmt(ListStmt *p) = 0;
    virtual void visitListItem(ListItem *p) = 0;
    virtual void visitListLatteIdent(ListLatteIdent *p) = 0;
    virtual void visitListExpr(ListExpr *p) = 0;


    virtual void visitInteger(Integer x) = 0;
    virtual void visitChar(Char x) = 0;
    virtual void visitDouble(Double x) = 0;
    virtual void visitString(String x) = 0;
    virtual void visitIdent(Ident x) = 0;

};


class Visitable
{
public:
    virtual ~Visitable() {}
    virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Program : public Visitable
{
public:
    virtual Program *clone() const = 0;
    int line_number;
};

class TopDef : public Visitable
{
public:
    virtual TopDef *clone() const = 0;
    int line_number;
};

class Arg : public Visitable
{
public:
    virtual Arg *clone() const = 0;
    int line_number;
};

class ClassInstr : public Visitable
{
public:
    virtual ClassInstr *clone() const = 0;
    int line_number;
};

class Block : public Visitable
{
public:
    virtual Block *clone() const = 0;
    int line_number;
};

class Stmt : public Visitable
{
public:
    virtual BStmt *getBlock(){return nullptr;};
    virtual CondElse *returnCondElse() {return nullptr;};
    virtual Cond *returnCond() {return nullptr;};
    virtual ListLatteIdent *simple() {return nullptr;};
    virtual Expr *expr() {return nullptr;};
    virtual bool isVRet() {return false;}
    virtual bool isRet() {return false;}
    virtual Stmt *clone() const = 0;
    int line_number;
};

class Item : public Visitable
{
public:
    virtual Ident getIdent() = 0;
    virtual Item *clone() const = 0;
    int line_number;
};

class LatteIdent : public Visitable
{
public:
    virtual Ident getIdent() = 0;
    virtual LatteIdent *clone() const = 0;
    int line_number;
};

class Type : public Visitable
{
public:
    virtual std::string getType() = 0;
    virtual Type *clone() const = 0;
    int line_number;
};

class Expr : public Visitable
{
public:
    virtual bool true_(){return false;};
    virtual bool false_(){return false;};
    virtual Expr *clone() const = 0;
    int line_number;
};

class AddOp : public Visitable
{
public:
    virtual bool isPlus() {return false;};
    virtual AddOp *clone() const = 0;
    int line_number;
};

class MulOp : public Visitable
{
public:
    virtual MulOp *clone() const = 0;
    int line_number;
};

class RelOp : public Visitable
{
public:
    virtual bool noOrder() {return false;};
    virtual RelOp *clone() const = 0;
    int line_number;
};



class Prog : public Program
{
public:
    ListTopDef *listtopdef_;

    Prog(const Prog &);
    Prog &operator=(const Prog &);
    Prog(ListTopDef *p1);
    ~Prog();
    virtual void accept(Visitor *v);
    virtual Prog *clone() const;
    void swap(Prog &);
};

class FnDef : public TopDef
{
public:
    Type *type_;
    Ident ident_;
    ListArg *listarg_;
    Block *block_;

    FnDef(const FnDef &);
    FnDef &operator=(const FnDef &);
    FnDef(Type *p1, Ident p2, ListArg *p3, Block *p4);
    ~FnDef();
    virtual void accept(Visitor *v);
    virtual FnDef *clone() const;
    void swap(FnDef &);
};

class ClassDefNoInher : public TopDef
{
public:
    Ident ident_;
    ListClassInstr *listclassinstr_;

    ClassDefNoInher(const ClassDefNoInher &);
    ClassDefNoInher &operator=(const ClassDefNoInher &);
    ClassDefNoInher(Ident p1, ListClassInstr *p2);
    ~ClassDefNoInher();
    virtual void accept(Visitor *v);
    virtual ClassDefNoInher *clone() const;
    void swap(ClassDefNoInher &);
};

class ClassDefInher : public TopDef
{
public:
    Ident ident_1;
    Ident ident_2;
    ListClassInstr *listclassinstr_;

    ClassDefInher(const ClassDefInher &);
    ClassDefInher &operator=(const ClassDefInher &);
    ClassDefInher(Ident p1, Ident p2, ListClassInstr *p3);
    ~ClassDefInher();
    virtual void accept(Visitor *v);
    virtual ClassDefInher *clone() const;
    void swap(ClassDefInher &);
};

class Ar : public Arg
{
public:
    Type *type_;
    Ident ident_;

    Ar(const Ar &);
    Ar &operator=(const Ar &);
    Ar(Type *p1, Ident p2);
    ~Ar();
    virtual void accept(Visitor *v);
    virtual Ar *clone() const;
    void swap(Ar &);
};

class MethodDef : public ClassInstr
{
public:
    Type *type_;
    Ident ident_;
    ListArg *listarg_;
    Block *block_;

    MethodDef(const MethodDef &);
    MethodDef &operator=(const MethodDef &);
    MethodDef(Type *p1, Ident p2, ListArg *p3, Block *p4);
    ~MethodDef();
    virtual void accept(Visitor *v);
    virtual MethodDef *clone() const;
    void swap(MethodDef &);
};

class FieldDef : public ClassInstr
{
public:
    Type *type_;
    Ident ident_;

    FieldDef(const FieldDef &);
    FieldDef &operator=(const FieldDef &);
    FieldDef(Type *p1, Ident p2);
    ~FieldDef();
    virtual void accept(Visitor *v);
    virtual FieldDef *clone() const;
    void swap(FieldDef &);
};

class Blk : public Block
{
public:
    ListStmt *liststmt_;

    Blk(const Blk &);
    Blk &operator=(const Blk &);
    Blk(ListStmt *p1);
    ~Blk();
    virtual void accept(Visitor *v);
    virtual Blk *clone() const;
    void swap(Blk &);
};

class Empty : public Stmt
{
public:

    Empty(const Empty &);
    Empty &operator=(const Empty &);
    Empty();
    ~Empty();
    virtual void accept(Visitor *v);
    virtual Empty *clone() const;
    void swap(Empty &);
};

class BStmt : public Stmt
{
public:
    BStmt *getBlock(){return this;};
    Block *block_;
    BStmt(const BStmt &);
    BStmt &operator=(const BStmt &);
    BStmt(Block *p1);
    ~BStmt();
    virtual void accept(Visitor *v);
    virtual BStmt *clone() const;
    void swap(BStmt &);
};

class Decl : public Stmt
{
public:
    Type *type_;
    ListItem *listitem_;

    Decl(const Decl &);
    Decl &operator=(const Decl &);
    Decl(Type *p1, ListItem *p2);
    ~Decl();
    virtual void accept(Visitor *v);
    virtual Decl *clone() const;
    void swap(Decl &);
};

class Ass : public Stmt
{
public:
    ListLatteIdent *listlatteident_;
    Expr *expr_;

    Ass(const Ass &);
    Ass &operator=(const Ass &);
    Ass(ListLatteIdent *p1, Expr *p2);
    ~Ass();
    virtual void accept(Visitor *v);
    virtual Ass *clone() const;
    void swap(Ass &);
};

class AssArr : public Stmt
{
public:
    ListLatteIdent *listlatteident_;
    Type *type_;
    Expr *expr_;

    AssArr(const AssArr &);
    AssArr &operator=(const AssArr &);
    AssArr(ListLatteIdent *p1, Type *p2, Expr *p3);
    ~AssArr();
    virtual void accept(Visitor *v);
    virtual AssArr *clone() const;
    void swap(AssArr &);
};

class AssObj : public Stmt
{
public:
    ListLatteIdent *listlatteident_;
    Type *type_;

    AssObj(const AssObj &);
    AssObj &operator=(const AssObj &);
    AssObj(ListLatteIdent *p1, Type *p2);
    ~AssObj();
    virtual void accept(Visitor *v);
    virtual AssObj *clone() const;
    void swap(AssObj &);
};

class Incr : public Stmt
{
public:
    ListLatteIdent *listlatteident_;
    ListLatteIdent *simple(){ return listlatteident_; };
    Incr(const Incr &);
    Incr &operator=(const Incr &);
    Incr(ListLatteIdent *p1);
    ~Incr();
    virtual void accept(Visitor *v);
    virtual Incr *clone() const;
    void swap(Incr &);
};

class Decr : public Stmt
{
public:
    ListLatteIdent *listlatteident_;
    ListLatteIdent *simple(){ return listlatteident_; };
    Decr(const Decr &);
    Decr &operator=(const Decr &);
    Decr(ListLatteIdent *p1);
    ~Decr();
    virtual void accept(Visitor *v);
    virtual Decr *clone() const;
    void swap(Decr &);
};

class Ret : public Stmt
{
public:
    std::string type;
    Expr *expr_;
    bool isRet() {return true;};
    Ret(const Ret &);
    Ret &operator=(const Ret &);
    Ret(Expr *p1);
    ~Ret();
    virtual void accept(Visitor *v);
    virtual Ret *clone() const;
    void swap(Ret &);
};

class VRet : public Stmt
{
public:
    bool isVRet() {return true;};
    VRet(const VRet &);
    VRet &operator=(const VRet &);
    VRet();
    ~VRet();
    virtual void accept(Visitor *v);
    virtual VRet *clone() const;
    void swap(VRet &);
};

class Cond : public Stmt
{
public:
    Expr *expr_;
    Stmt *stmt_;
    Cond *returnCond() {return this;};
    Cond(const Cond &);
    Cond &operator=(const Cond &);
    Cond(Expr *p1, Stmt *p2);
    ~Cond();
    virtual void accept(Visitor *v);
    virtual Cond *clone() const;
    void swap(Cond &);
};

class CondElse : public Stmt
{
public:
    Expr *expr_;
    Stmt *stmt_1;
    Stmt *stmt_2;
    CondElse *returnCondElse(){return this;};
    CondElse(const CondElse &);
    CondElse &operator=(const CondElse &);
    CondElse(Expr *p1, Stmt *p2, Stmt *p3);
    ~CondElse();
    virtual void accept(Visitor *v);
    virtual CondElse *clone() const;
    void swap(CondElse &);
};

class While : public Stmt
{
public:
    Expr *expr_;
    Stmt *stmt_;

    While(const While &);
    While &operator=(const While &);
    While(Expr *p1, Stmt *p2);
    ~While();
    virtual void accept(Visitor *v);
    virtual While *clone() const;
    void swap(While &);
};

class Foreach : public Stmt
{
public:
    Type *type_;
    Ident ident_;
    ListLatteIdent *listlatteident_;
    Stmt *stmt_;

    Foreach(const Foreach &);
    Foreach &operator=(const Foreach &);
    Foreach(Type *p1, Ident p2, ListLatteIdent *p3, Stmt *p4);
    ~Foreach();
    virtual void accept(Visitor *v);
    virtual Foreach *clone() const;
    void swap(Foreach &);
};

class SExp : public Stmt
{
public:
    Expr *expr_;
    Expr *expr() {return expr_;};
    SExp(const SExp &);
    SExp &operator=(const SExp &);
    SExp(Expr *p1);
    ~SExp();
    virtual void accept(Visitor *v);
    virtual SExp *clone() const;
    void swap(SExp &);
};

class NoInit : public Item
{
public:
    Ident ident_;

    Ident getIdent(){return ident_;};
    NoInit(const NoInit &);
    NoInit &operator=(const NoInit &);
    NoInit(Ident p1);
    ~NoInit();
    virtual void accept(Visitor *v);
    virtual NoInit *clone() const;
    void swap(NoInit &);
};

class Init : public Item
{
public:
    Ident ident_;
    Expr *expr_;

    Ident getIdent(){return ident_;};
    Init(const Init &);
    Init &operator=(const Init &);
    Init(Ident p1, Expr *p2);
    ~Init();
    virtual void accept(Visitor *v);
    virtual Init *clone() const;
    void swap(Init &);
};

class InitArray : public Item
{
public:
    Ident ident_;
    Type *type_;
    Expr *expr_;

    Ident getIdent(){return ident_;};
    InitArray(const InitArray &);
    InitArray &operator=(const InitArray &);
    InitArray(Ident p1, Type *p2, Expr *p3);
    ~InitArray();
    virtual void accept(Visitor *v);
    virtual InitArray *clone() const;
    void swap(InitArray &);
};

class InitObj : public Item
{
public:
    Ident ident_;
    Type *type_;

    Ident getIdent(){return ident_;};
    InitObj(const InitObj &);
    InitObj &operator=(const InitObj &);
    InitObj(Ident p1, Type *p2);
    ~InitObj();
    virtual void accept(Visitor *v);
    virtual InitObj *clone() const;
    void swap(InitObj &);
};

class SingleIdent : public LatteIdent
{
public:
    Ident ident_;

    Ident getIdent(){ return this->ident_; };
    SingleIdent(const SingleIdent &);
    SingleIdent &operator=(const SingleIdent &);
    SingleIdent(Ident p1);
    ~SingleIdent();
    virtual void accept(Visitor *v);
    virtual SingleIdent *clone() const;
    void swap(SingleIdent &);
};

class ArrayIdent : public LatteIdent
{
public:
    Ident ident_;
    Expr *expr_;

    Ident getIdent() { this->ident_; };
    ArrayIdent(const ArrayIdent &);
    ArrayIdent &operator=(const ArrayIdent &);
    ArrayIdent(Ident p1, Expr *p2);
    ~ArrayIdent();
    virtual void accept(Visitor *v);
    virtual ArrayIdent *clone() const;
    void swap(ArrayIdent &);
};

class SelfIdent : public LatteIdent
{
public:
    Ident getIdent() { return ""; };
    SelfIdent(const SelfIdent &);
    SelfIdent &operator=(const SelfIdent &);
    SelfIdent();
    ~SelfIdent();
    virtual void accept(Visitor *v);
    virtual SelfIdent *clone() const;
    void swap(SelfIdent &);
};

class Class : public Type
{
public:
    Ident ident_;
    std::string getType(){return ident_;};
    Class(const Class &);
    Class &operator=(const Class &);
    Class(Ident p1);
    ~Class();
    virtual void accept(Visitor *v);
    virtual Class *clone() const;
    void swap(Class &);
};

class Int : public Type
{
public:
    std::string getType(){return "int";};
    Int(const Int &);
    Int &operator=(const Int &);
    Int();
    ~Int();
    virtual void accept(Visitor *v);
    virtual Int *clone() const;
    void swap(Int &);
};

class Str : public Type
{
public:
    std::string getType(){return "string";}
    Str(const Str &);
    Str &operator=(const Str &);
    Str();
    ~Str();
    virtual void accept(Visitor *v);
    virtual Str *clone() const;
    void swap(Str &);
};

class Bool : public Type
{
public:
    std::string getType(){return "boolean";}
    Bool(const Bool &);
    Bool &operator=(const Bool &);
    Bool();
    ~Bool();
    virtual void accept(Visitor *v);
    virtual Bool *clone() const;
    void swap(Bool &);
};

class Void : public Type
{
public:
    std::string getType(){return "void";}
    Void(const Void &);
    Void &operator=(const Void &);
    Void();
    ~Void();
    virtual void accept(Visitor *v);
    virtual Void *clone() const;
    void swap(Void &);
};

class ArrayType : public Type
{
public:
    Type *type_;
    std::string getType(){return type_->getType() + "[]";}
    ArrayType(const ArrayType &);
    ArrayType &operator=(const ArrayType &);
    ArrayType(Type *p1);
    ~ArrayType();
    virtual void accept(Visitor *v);
    virtual ArrayType *clone() const;
    void swap(ArrayType &);
};

class EVar : public Expr
{
public:
    ListLatteIdent *listlatteident_;

    EVar(const EVar &);
    EVar &operator=(const EVar &);
    EVar(ListLatteIdent *p1);
    ~EVar();
    virtual void accept(Visitor *v);
    virtual EVar *clone() const;
    void swap(EVar &);
};

class ELitInt : public Expr
{
public:
    Integer integer_;

    ELitInt(const ELitInt &);
    ELitInt &operator=(const ELitInt &);
    ELitInt(Integer p1);
    ~ELitInt();
    virtual void accept(Visitor *v);
    virtual ELitInt *clone() const;
    void swap(ELitInt &);
};

class ELitFalse : public Expr
{
public:
    bool false_(){return true;};
    ELitFalse(const ELitFalse &);
    ELitFalse &operator=(const ELitFalse &);
    ELitFalse();
    ~ELitFalse();
    virtual void accept(Visitor *v);
    virtual ELitFalse *clone() const;
    void swap(ELitFalse &);
};

class ELitNull : public Expr
{
public:

    ELitNull(const ELitNull &);
    ELitNull &operator=(const ELitNull &);
    ELitNull();
    ~ELitNull();
    virtual void accept(Visitor *v);
    virtual ELitNull *clone() const;
    void swap(ELitNull &);
};

class ELitTrue : public Expr
{
public:
    bool true_(){return true;};
    ELitTrue(const ELitTrue &);
    ELitTrue &operator=(const ELitTrue &);
    ELitTrue();
    ~ELitTrue();
    virtual void accept(Visitor *v);
    virtual ELitTrue *clone() const;
    void swap(ELitTrue &);
};

class EApp : public Expr
{
public:
    Ident ident_;
    ListExpr *listexpr_;

    EApp(const EApp &);
    EApp &operator=(const EApp &);
    EApp(Ident p1, ListExpr *p2);
    ~EApp();
    virtual void accept(Visitor *v);
    virtual EApp *clone() const;
    void swap(EApp &);
};

class EInstanceApp : public Expr
{
public:
    ListLatteIdent *listlatteident_;
    ListExpr *listexpr_;

    EInstanceApp(const EInstanceApp &);
    EInstanceApp &operator=(const EInstanceApp &);
    EInstanceApp(ListLatteIdent *p1, ListExpr *p2);
    ~EInstanceApp();
    virtual void accept(Visitor *v);
    virtual EInstanceApp *clone() const;
    void swap(EInstanceApp &);
};

class EString : public Expr
{
public:
    String string_;

    EString(const EString &);
    EString &operator=(const EString &);
    EString(String p1);
    ~EString();
    virtual void accept(Visitor *v);
    virtual EString *clone() const;
    void swap(EString &);
};

class Neg : public Expr
{
public:
    Expr *expr_;

    Neg(const Neg &);
    Neg &operator=(const Neg &);
    Neg(Expr *p1);
    ~Neg();
    virtual void accept(Visitor *v);
    virtual Neg *clone() const;
    void swap(Neg &);
};

class Not : public Expr
{
public:
    Expr *expr_;

    Not(const Not &);
    Not &operator=(const Not &);
    Not(Expr *p1);
    ~Not();
    virtual void accept(Visitor *v);
    virtual Not *clone() const;
    void swap(Not &);
};

class ECast : public Expr
{
public:
    Ident ident_;
    Expr *expr_;

    ECast(const ECast &);
    ECast &operator=(const ECast &);
    ECast(Ident p1, Expr *p2);
    ~ECast();
    virtual void accept(Visitor *v);
    virtual ECast *clone() const;
    void swap(ECast &);
};

class EMul : public Expr
{
public:
    Expr *expr_1;
    MulOp *mulop_;
    Expr *expr_2;

    EMul(const EMul &);
    EMul &operator=(const EMul &);
    EMul(Expr *p1, MulOp *p2, Expr *p3);
    ~EMul();
    virtual void accept(Visitor *v);
    virtual EMul *clone() const;
    void swap(EMul &);
};

class EAdd : public Expr
{
public:
    Expr *expr_1;
    AddOp *addop_;
    Expr *expr_2;

    EAdd(const EAdd &);
    EAdd &operator=(const EAdd &);
    EAdd(Expr *p1, AddOp *p2, Expr *p3);
    ~EAdd();
    virtual void accept(Visitor *v);
    virtual EAdd *clone() const;
    void swap(EAdd &);
};

class ERel : public Expr
{
public:
    Expr *expr_1;
    RelOp *relop_;
    Expr *expr_2;

    ERel(const ERel &);
    ERel &operator=(const ERel &);
    ERel(Expr *p1, RelOp *p2, Expr *p3);
    ~ERel();
    virtual void accept(Visitor *v);
    virtual ERel *clone() const;
    void swap(ERel &);
};

class EAnd : public Expr
{
public:
    Expr *expr_1;
    Expr *expr_2;

    EAnd(const EAnd &);
    EAnd &operator=(const EAnd &);
    EAnd(Expr *p1, Expr *p2);
    ~EAnd();
    virtual void accept(Visitor *v);
    virtual EAnd *clone() const;
    void swap(EAnd &);
};

class EOr : public Expr
{
public:
    Expr *expr_1;
    Expr *expr_2;

    EOr(const EOr &);
    EOr &operator=(const EOr &);
    EOr(Expr *p1, Expr *p2);
    ~EOr();
    virtual void accept(Visitor *v);
    virtual EOr *clone() const;
    void swap(EOr &);
};

class Plus : public AddOp
{
public:
    bool isPlus() {return true;};
    Plus(const Plus &);
    Plus &operator=(const Plus &);
    Plus();
    ~Plus();
    virtual void accept(Visitor *v);
    virtual Plus *clone() const;
    void swap(Plus &);
};

class Minus : public AddOp
{
public:

    Minus(const Minus &);
    Minus &operator=(const Minus &);
    Minus();
    ~Minus();
    virtual void accept(Visitor *v);
    virtual Minus *clone() const;
    void swap(Minus &);
};

class Times : public MulOp
{
public:

    Times(const Times &);
    Times &operator=(const Times &);
    Times();
    ~Times();
    virtual void accept(Visitor *v);
    virtual Times *clone() const;
    void swap(Times &);
};

class Div : public MulOp
{
public:

    Div(const Div &);
    Div &operator=(const Div &);
    Div();
    ~Div();
    virtual void accept(Visitor *v);
    virtual Div *clone() const;
    void swap(Div &);
};

class Mod : public MulOp
{
public:

    Mod(const Mod &);
    Mod &operator=(const Mod &);
    Mod();
    ~Mod();
    virtual void accept(Visitor *v);
    virtual Mod *clone() const;
    void swap(Mod &);
};

class LTH : public RelOp
{
public:

    LTH(const LTH &);
    LTH &operator=(const LTH &);
    LTH();
    ~LTH();
    virtual void accept(Visitor *v);
    virtual LTH *clone() const;
    void swap(LTH &);
};

class LE : public RelOp
{
public:

    LE(const LE &);
    LE &operator=(const LE &);
    LE();
    ~LE();
    virtual void accept(Visitor *v);
    virtual LE *clone() const;
    void swap(LE &);
};

class GTH : public RelOp
{
public:

    GTH(const GTH &);
    GTH &operator=(const GTH &);
    GTH();
    ~GTH();
    virtual void accept(Visitor *v);
    virtual GTH *clone() const;
    void swap(GTH &);
};

class GE : public RelOp
{
public:

    GE(const GE &);
    GE &operator=(const GE &);
    GE();
    ~GE();
    virtual void accept(Visitor *v);
    virtual GE *clone() const;
    void swap(GE &);
};

class EQU : public RelOp
{
public:
    bool noOrder(){return true;};
    EQU(const EQU &);
    EQU &operator=(const EQU &);
    EQU();
    ~EQU();
    virtual void accept(Visitor *v);
    virtual EQU *clone() const;
    void swap(EQU &);
};

class NE : public RelOp
{
public:
    bool noOrder(){return true;};
    NE(const NE &);
    NE &operator=(const NE &);
    NE();
    ~NE();
    virtual void accept(Visitor *v);
    virtual NE *clone() const;
    void swap(NE &);
};



class ListTopDef : public Visitable, public std::vector<TopDef*>
{
public:
    virtual void accept(Visitor *v);
    virtual ListTopDef *clone() const;
};

class ListArg : public Visitable, public std::vector<Arg*>
{
public:
    virtual void accept(Visitor *v);
    virtual ListArg *clone() const;
};

class ListClassInstr : public Visitable, public std::vector<ClassInstr*>
{
public:
    virtual void accept(Visitor *v);
    virtual ListClassInstr *clone() const;
};

class ListStmt : public Visitable, public std::vector<Stmt*>
{
public:
    virtual void accept(Visitor *v);
    virtual ListStmt *clone() const;
};

class ListItem : public Visitable, public std::vector<Item*>
{
public:
    virtual void accept(Visitor *v);
    virtual ListItem *clone() const;
};

class ListLatteIdent : public Visitable, public std::vector<LatteIdent*>
{
public:
    virtual void accept(Visitor *v);
    virtual ListLatteIdent *clone() const;
};

class ListExpr : public Visitable, public std::vector<Expr*>
{
public:
    virtual void accept(Visitor *v);
    virtual ListExpr *clone() const;
};



#endif
